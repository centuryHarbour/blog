# 小程序触底加载更多内容的实现

## 首先看看展示效果

![](https://www.github.com/kingshuaishuai/static_resource/raw/master/assets/0bd9f6dd716003f3818d15d2e211ee73.gif)

## 实现思路
**上拉加载更多的细节：**
1. 触底: 监测触底事件在触底之后执行一系列动作
2. 加载数据: 在触底后需要向服务器请求数据，如果已经请求到了所有数据，应该不再发送请求。
3. 加载状态: 请求数据的等待时间，需要更新状态为加载中，数据渲染完成后取消该状态的显示
4. 数据渲染: 将请求到的数据显示在视图中
5. 没有更多数据的提示

**优化项**
1. 防止多次请求
2. 封装：如何在多个页面应用同一套实现代码

## 功能的实现
### 数据结构的确定
数据结构来源7七月老师的[(风袖API文档)](https://course.7yue.pro/lin/sleeve/1%20%E3%80%8A%E9%A3%8E%E8%A2%96%E3%80%8B%E5%85%A8%E6%A0%88%E8%AF%BEAPI%E6%96%87%E6%A1%A3.html#%E5%88%86%E9%A1%B5%E5%8F%82%E6%95%B0)
```json
{
    "total":1,
    "count":10,
    "page":0,
    "total_page":1,
    "items":[
        {
            "id":8,
            "title":"ins复古翠绿NoteBook",
            "subtitle":"林白默默的掏出小本本，将她说的话一次不漏的记了下来。",
            "img":"",
            "for_theme_img":"",
            "price":"29.99",
            "discount_price":"27.8",
            "description":null,
            "tags":"林白推荐",
            "sketch_spec_id":"1",
            "max_purchase_quantity":null,
            "min_purchase_quantity":null
        }
    ]
}
```
### ajax与后端的模拟
```javascript
// /model/Products.js
class Products {
  static store = [
    {
      id: 'P001',
      title: '人间值得',
      subtitle: '愿你遍历山河，仍觉人间值得！',
      img: '/images/人间值得.png',
      price: "49.90",
      discount_price: "46.30",
      labels: ['人间值得', '恒子奶奶'],
      for_theme_img: "",
    },
    // .....本文这里给出一条数据，其余的省略
  ]
  constructor() {
    this.total = Products.store.length;
  }

  async getPorductList({ count = 5, page = 1 }) {
    this.count = count;
    this.page = page;
    this.total_page = Math.ceil(this.total / this.count);
    const start = (this.page - 1) * this.count;
    const end = this.page * this.count;
    this.items = Products.store.slice(start, end);
    
    return new Promise((resolve) => {
      resolve(this._getDataTemplate())
    })
  }

  _getDataTemplate() {
    return {
      total: this.total,
      count: this.count,
      total_page: this.total_page,
      page: this.page,
      items: this.items
    }
  }
}
```

通过构造一个Products类，模拟数据库以及对数据库的请求。
* 静态属性`store`代表数据库中的数据，
* `_getDataTemplate`对数据格式进行组装，模拟后端对数据的处理，
* `getPorductList`方法模拟请求后端数据，每次请求默认5条数据，可以配置请求数据条数与请求页数，最终将数据进行包装后返回一个经过promise。

### loading组件的封装
一个项目的loading风格是统一的，这里选择了易用性而舍弃了灵活性。
```html
<view class="loading-container" wx:if="{{show}}">
  <view class="loading" wx:if="{{loading}}">
    <image class="loading-img" src="/images/loading.gif"></image>
    <text class="loading-text">加载中</text>
  </view>
  <view class="done" wx:else>
    我也是有底线的~
  </view>
</view>
```
通过设置`show`属性来显示或隐藏loading组件，通过设置`loading`属性来选择显示loading的状态

### data的确定
```javascript
data: {
    loadingStatus: true,  // loading状态（加载中/无数据）的控制
    loadingShow: false, // loading组件的显示控制
    products: [], // 展示的数据
    productModel: null, // Products类创建的对象模型
    currentPage: 1, // 当请求页的设置
    pageCount: 5 // 每页请求数据的数量
  },

```

### 第一组数据的获取
```javascript
async onLoad (options) {
    const productModel = new Products();
    const products = await productModel.getPorductList({
      count: this.data.pageCount, 
      page: this.data.currentPage
    })
    this.setData({
      productModel,
      products: products,
    });
    this.renderWaterFlow();
  },

  renderWaterFlow() {
    wx.lin.renderWaterFlow(this.data.products.items, false, () => {
      this.setData({
        loadingShow: false,
      })
    })
  },
```
进入页面在没有触发触底事件时，应当加载一组数据进行正常的显示。所以选择在`onLoad`生命周期中进行。
这里创建了`Products`类的实例`productModel`方便后续向后端发送请求获取数据。紧接着调用该实例的`getPorductList`方法，并传入请求页与每页显示数据条数获取第一组数据，并将其更新到data中。
最后调用`lin-ui`提供的[瀑布流组件](http://doc.mini.7yue.pro/component/layout/water-flow.html#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95)进行数据的渲染。